#include "particle.h"
PbWrapperRegistry::instance().addClass("ParticleBase", "ParticleBase", "PbClass");
template<> ParticleBase* fromPy<ParticleBase*>(PyObject* obj) { if (PbClass::isNullRef(obj)) return 0; PbClass* pbo = PbClass::fromPyObject(obj); if (!pbo || !(pbo->canConvertTo("ParticleBase"))) throw Error("can't convert argument to type 'ParticleBase'"); return dynamic_cast<ParticleBase*>(pbo); }
template<> PyObject* toPy< ParticleBase >( ParticleBase& v) { if (v.getPyObject()) return v.getPyObject(); ParticleBase* co = new ParticleBase (v); return co->assignNewPyObject("ParticleBase"); }
int _ParticleBase_ParticleBase (PyObject* _self, PyObject* _linargs, PyObject* _kwds) { PbClass* obj = PbClass::fromPyObject(_self); if (obj) delete obj; try { PbArgs _args(_linargs, _kwds); pbPreparePlugin(0, "ParticleBase::ParticleBase"); { ArgLocker _lock; FluidSolver* parent = _args.get< FluidSolver* > (0,"parent", &_lock); obj = new ParticleBase(parent);std::string _name = _args.getOpt<std::string>("name",""); obj->setPyObject(_self); if (!_name.empty()) obj->setName(_name); _args.check(); } pbFinalizePlugin(obj->getParent(),"ParticleBase::ParticleBase"); return 0; } catch(std::exception& e) { pbSetError("ParticleBase::ParticleBase",e.what()); return -1; } } 
PbWrapperRegistry::instance().addConstructor("ParticleBase", _ParticleBase_ParticleBase);
#include "particle.h"
@template ParticleSystem PbWrapperRegistry::instance().addClass("@", "ParticleSystem<$$>", "ParticleBase");
@template ParticleSystem int _ParticleSystem@_ParticleSystem@ (PyObject* _self, PyObject* _linargs, PyObject* _kwds) { PbClass* obj = PbClass::fromPyObject(_self); if (obj) delete obj; try { PbArgs _args(_linargs, _kwds); pbPreparePlugin(0, "ParticleSystem::ParticleSystem"); { ArgLocker _lock; FluidSolver* parent = _args.get< FluidSolver* > (0,"parent", &_lock); obj = new ParticleSystem<$$> (parent);std::string _name = _args.getOpt<std::string>("name",""); obj->setPyObject(_self); if (!_name.empty()) obj->setName(_name); _args.check(); } pbFinalizePlugin(obj->getParent(),"ParticleSystem::ParticleSystem"); return 0; } catch(std::exception& e) { pbSetError("ParticleSystem::ParticleSystem",e.what()); return -1; } } 
@template ParticleSystem PbWrapperRegistry::instance().addConstructor("ParticleSystem<$$>", _ParticleSystem@_ParticleSystem@);
@template ParticleSystem PyObject* _ParticleSystem@_size (PyObject* _self, PyObject* _linargs, PyObject* _kwds) { return dynamic_cast<ParticleSystem<$$>*>(PbClass::fromPyObject(_self))->_size(_self, _linargs, _kwds); }
@template ParticleSystem PbWrapperRegistry::instance().addMethod("ParticleSystem<$$>", "size", _ParticleSystem@_size);
@template ParticleSystem PyObject* _ParticleSystem@_setPos (PyObject* _self, PyObject* _linargs, PyObject* _kwds) { return dynamic_cast<ParticleSystem<$$>*>(PbClass::fromPyObject(_self))->_setPos(_self, _linargs, _kwds); }
@template ParticleSystem PbWrapperRegistry::instance().addMethod("ParticleSystem<$$>", "setPos", _ParticleSystem@_setPos);
@template ParticleSystem PyObject* _ParticleSystem@_getPos (PyObject* _self, PyObject* _linargs, PyObject* _kwds) { return dynamic_cast<ParticleSystem<$$>*>(PbClass::fromPyObject(_self))->_getPos(_self, _linargs, _kwds); }
@template ParticleSystem PbWrapperRegistry::instance().addMethod("ParticleSystem<$$>", "getPos", _ParticleSystem@_getPos);
@template ParticleSystem PyObject* _ParticleSystem@_advectInGrid (PyObject* _self, PyObject* _linargs, PyObject* _kwds) { return dynamic_cast<ParticleSystem<$$>*>(PbClass::fromPyObject(_self))->_advectInGrid(_self, _linargs, _kwds); }
@template ParticleSystem PbWrapperRegistry::instance().addMethod("ParticleSystem<$$>", "advectInGrid", _ParticleSystem@_advectInGrid);
@instance ParticleSystem BasicParticleData _ParticleSystem_BasicParticleData
#include "particle.h"
PbWrapperRegistry::instance().addClass("TracerParticleSystem", "TracerParticleSystem", "ParticleSystem<BasicParticleData>");
template<> TracerParticleSystem* fromPy<TracerParticleSystem*>(PyObject* obj) { if (PbClass::isNullRef(obj)) return 0; PbClass* pbo = PbClass::fromPyObject(obj); if (!pbo || !(pbo->canConvertTo("TracerParticleSystem"))) throw Error("can't convert argument to type 'TracerParticleSystem'"); return dynamic_cast<TracerParticleSystem*>(pbo); }
template<> PyObject* toPy< TracerParticleSystem >( TracerParticleSystem& v) { if (v.getPyObject()) return v.getPyObject(); TracerParticleSystem* co = new TracerParticleSystem (v); return co->assignNewPyObject("TracerParticleSystem"); }
int _TracerParticleSystem_TracerParticleSystem (PyObject* _self, PyObject* _linargs, PyObject* _kwds) { PbClass* obj = PbClass::fromPyObject(_self); if (obj) delete obj; try { PbArgs _args(_linargs, _kwds); pbPreparePlugin(0, "TracerParticleSystem::TracerParticleSystem"); { ArgLocker _lock; FluidSolver* parent = _args.get< FluidSolver* > (0,"parent", &_lock); obj = new TracerParticleSystem(parent);std::string _name = _args.getOpt<std::string>("name",""); obj->setPyObject(_self); if (!_name.empty()) obj->setName(_name); _args.check(); } pbFinalizePlugin(obj->getParent(),"TracerParticleSystem::TracerParticleSystem"); return 0; } catch(std::exception& e) { pbSetError("TracerParticleSystem::TracerParticleSystem",e.what()); return -1; } } 
PbWrapperRegistry::instance().addConstructor("TracerParticleSystem", _TracerParticleSystem_TracerParticleSystem);
PyObject* _TracerParticleSystem_addParticle (PyObject* _self, PyObject* _linargs, PyObject* _kwds) { return fromPy<TracerParticleSystem*>(_self)->_addParticle(_self, _linargs, _kwds); }
PbWrapperRegistry::instance().addMethod("TracerParticleSystem", "addParticle", _TracerParticleSystem_addParticle);
PyObject* _TracerParticleSystem_add_Particle (PyObject* _self, PyObject* _linargs, PyObject* _kwds) { return fromPy<TracerParticleSystem*>(_self)->_add_Particle(_self, _linargs, _kwds); }
PbWrapperRegistry::instance().addMethod("TracerParticleSystem", "add_Particle", _TracerParticleSystem_add_Particle);
@chain ConnectedParticleSystem @DATA@,@CON@ ParticleSystem @DATA@
#include "particle.h"
@template ConnectedParticleSystem PbWrapperRegistry::instance().addClass("@", "ConnectedParticleSystem<$$>", "ParticleSystem<$0$>");
@template ConnectedParticleSystem int _ConnectedParticleSystem@_ConnectedParticleSystem@ (PyObject* _self, PyObject* _linargs, PyObject* _kwds) { PbClass* obj = PbClass::fromPyObject(_self); if (obj) delete obj; try { PbArgs _args(_linargs, _kwds); pbPreparePlugin(0, "ConnectedParticleSystem::ConnectedParticleSystem"); { ArgLocker _lock; FluidSolver* parent = _args.get< FluidSolver* > (0,"parent", &_lock); obj = new ConnectedParticleSystem<$$> (parent);std::string _name = _args.getOpt<std::string>("name",""); obj->setPyObject(_self); if (!_name.empty()) obj->setName(_name); _args.check(); } pbFinalizePlugin(obj->getParent(),"ConnectedParticleSystem::ConnectedParticleSystem"); return 0; } catch(std::exception& e) { pbSetError("ConnectedParticleSystem::ConnectedParticleSystem",e.what()); return -1; } } 
@template ConnectedParticleSystem PbWrapperRegistry::instance().addConstructor("ConnectedParticleSystem<$$>", _ConnectedParticleSystem@_ConnectedParticleSystem@);
